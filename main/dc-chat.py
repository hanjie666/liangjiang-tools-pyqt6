# Form implementation generated from reading ui file 'view/dc-chat.ui'
#
# Created by: PyQt6 UI code generator 6.4.2
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.
import sys
import os
import json
import random
import time
import requests
from datetime import datetime
import threading
import traceback

from PyQt6 import QtCore, QtGui, QtWidgets
from PyQt6.QtWidgets import QWidget, QMessageBox
from PyQt6.QtCore import QObject, pyqtSignal

# 创建一个信号类，用于线程安全地更新UI
class LogSignals(QObject):
    log_signal = pyqtSignal(str)


class Ui_Form(QWidget):
    def __init__(self):
        super(QWidget, self).__init__()
        self.setupUi(self)
        
        # 创建信号对象
        self.signals = LogSignals()
        self.signals.log_signal.connect(self.update_log)
        
        # 配置文件路径
        current_dir = os.path.dirname(os.path.abspath(__file__))
        self.config_file = os.path.join(current_dir, 'dc_chat_config.json')
        
        # 如果配置文件不存在，尝试其他可能的路径
        if not os.path.exists(self.config_file):
            # 如果是打包后的应用
            if getattr(sys, 'frozen', False):
                # 尝试从Resources目录加载
                if sys.platform == 'darwin':
                    # macOS应用程序包
                    executable_dir = os.path.dirname(sys.executable)
                    if 'Contents/MacOS' in executable_dir:
                        resources_dir = os.path.join(os.path.dirname(os.path.dirname(executable_dir)), 'Resources')
                        self.config_file = os.path.join(resources_dir, 'main', 'dc_chat_config.json')
                        print(f"尝试从Resources目录加载dc_chat_config.json: {self.config_file}")
        
        # 如果仍然找不到文件，使用当前目录
        if not os.path.exists(self.config_file):
            self.config_file = os.path.join(os.getcwd(), 'dc_chat_config.json')
            print(f"使用当前目录的dc_chat_config.json: {self.config_file}")
        
        # 如果配置文件不存在，尝试其他可能的路径
        if not os.path.exists(self.config_file):
            # 如果是打包后的应用
            if getattr(sys, 'frozen', False):
                # 尝试从Resources目录加载
                if sys.platform == 'darwin':
                    # macOS应用程序包
                    executable_dir = os.path.dirname(sys.executable)
                    if 'Contents/MacOS' in executable_dir:
                        resources_dir = os.path.join(os.path.dirname(os.path.dirname(executable_dir)), 'Resources')
                        self.config_file = os.path.join(resources_dir, 'main', 'dc_chat_config.json')
                        print(f"尝试从Resources目录加载dc_chat_config.json: {self.config_file}")
        
        # 如果仍然找不到文件，使用当前目录
        if not os.path.exists(self.config_file):
            self.config_file = os.path.join(os.getcwd(), 'dc_chat_config.json')
            print(f"使用当前目录的dc_chat_config.json: {self.config_file}")
        
        # 加载保存的配置
        self.load_config()
        
        # 连接信号和槽
        self.lineEdit.textChanged.connect(self.save_config)  # DC TOKEN
        self.lineEdit_2.textChanged.connect(self.save_config)  # DC 频道
        self.lineEdit_3.textChanged.connect(self.save_config)  # API KEY
        self.lineEdit_4.textChanged.connect(self.save_config)  # 延时最小值
        self.lineEdit_5.textChanged.connect(self.save_config)  # 延时最大值
        self.comboBox_language.currentIndexChanged.connect(self.save_config)  # 回复语言
        
        # 连接按钮事件
        self.pushButton_2.clicked.connect(self.start_bot)  # 开始按钮
        self.pushButton.clicked.connect(self.stop_bot)  # 停止按钮
        
        # 机器人运行状态
        self.running = False
        self.bot_thread = None
        
        # 设置窗口关闭事件
        self.closeEvent = self.handle_close_event

    def setupUi(self, Form):
        Form.setObjectName("Form")
        Form.resize(394, 396)
        
        # 使用垂直布局作为主布局
        self.mainLayout = QtWidgets.QVBoxLayout(Form)
        self.mainLayout.setContentsMargins(20, 20, 20, 20)
        self.mainLayout.setSpacing(10)
        self.mainLayout.setObjectName("mainLayout")
        
        # 创建表单布局并添加到主布局
        self.formLayout = QtWidgets.QFormLayout()
        self.formLayout.setContentsMargins(0, 0, 0, 0)
        self.formLayout.setObjectName("formLayout")
        self.formLayout.setLabelAlignment(QtCore.Qt.AlignmentFlag.AlignRight)
        self.formLayout.setFieldGrowthPolicy(QtWidgets.QFormLayout.FieldGrowthPolicy.ExpandingFieldsGrow)
        
        # DC TOKEN
        self.label = QtWidgets.QLabel()
        self.label.setObjectName("label")
        self.label.setMinimumWidth(80)
        self.lineEdit = QtWidgets.QLineEdit()
        self.lineEdit.setObjectName("lineEdit")
        self.formLayout.addRow(self.label, self.lineEdit)
        
        # DC 频道
        self.label_2 = QtWidgets.QLabel()
        self.label_2.setObjectName("label_2")
        self.label_2.setMinimumWidth(80)
        self.lineEdit_2 = QtWidgets.QLineEdit()
        self.lineEdit_2.setObjectName("lineEdit_2")
        self.formLayout.addRow(self.label_2, self.lineEdit_2)
        
        # API KEY
        self.label_3 = QtWidgets.QLabel()
        self.label_3.setObjectName("label_3")
        self.label_3.setMinimumWidth(80)
        self.lineEdit_3 = QtWidgets.QLineEdit()
        self.lineEdit_3.setObjectName("lineEdit_3")
        self.formLayout.addRow(self.label_3, self.lineEdit_3)
        
        # 回复语言
        self.label_6 = QtWidgets.QLabel()
        self.label_6.setObjectName("label_6")
        self.label_6.setMinimumWidth(80)
        self.comboBox_language = QtWidgets.QComboBox()
        self.comboBox_language.setObjectName("comboBox_language")
        self.comboBox_language.addItem("中文")
        self.comboBox_language.addItem("英文")
        self.formLayout.addRow(self.label_6, self.comboBox_language)
        
        self.mainLayout.addLayout(self.formLayout)
        
        # 延时设置
        self.delayLayout = QtWidgets.QHBoxLayout()
        self.delayLayout.setContentsMargins(0, 0, 0, 0)
        self.delayLayout.setObjectName("delayLayout")
        
        self.label_4 = QtWidgets.QLabel()
        self.label_4.setObjectName("label_4")
        self.label_4.setMinimumWidth(80)
        self.delayLayout.addWidget(self.label_4)
        
        self.lineEdit_4 = QtWidgets.QLineEdit()
        self.lineEdit_4.setObjectName("lineEdit_4")
        self.lineEdit_4.setText("300")  # 默认最小延时
        self.delayLayout.addWidget(self.lineEdit_4)
        
        self.label_5 = QtWidgets.QLabel()
        self.label_5.setObjectName("label_5")
        self.delayLayout.addWidget(self.label_5)
        
        self.lineEdit_5 = QtWidgets.QLineEdit()
        self.lineEdit_5.setObjectName("lineEdit_5")
        self.lineEdit_5.setText("350")  # 默认最大延时
        self.delayLayout.addWidget(self.lineEdit_5)
        
        self.mainLayout.addLayout(self.delayLayout)
        
        # 按钮布局
        self.buttonLayout = QtWidgets.QHBoxLayout()
        self.buttonLayout.setContentsMargins(0, 0, 0, 0)
        self.buttonLayout.setObjectName("buttonLayout")
        
        self.pushButton_2 = QtWidgets.QPushButton()
        self.pushButton_2.setObjectName("pushButton_2")
        self.buttonLayout.addWidget(self.pushButton_2)
        
        self.pushButton = QtWidgets.QPushButton()
        self.pushButton.setObjectName("pushButton")
        self.buttonLayout.addWidget(self.pushButton)
        
        self.mainLayout.addLayout(self.buttonLayout)
        
        # 文本编辑区
        self.plainTextEdit = QtWidgets.QPlainTextEdit()
        self.plainTextEdit.setObjectName("plainTextEdit")
        self.plainTextEdit.setMinimumHeight(150)
        self.plainTextEdit.setReadOnly(True)  # 设置为只读
        self.mainLayout.addWidget(self.plainTextEdit)
        
        self.retranslateUi(Form)
        QtCore.QMetaObject.connectSlotsByName(Form)

    def retranslateUi(self, Form):
        _translate = QtCore.QCoreApplication.translate
        Form.setWindowTitle(_translate("Form", "DC自动聊天"))
        self.label.setText(_translate("Form", "DC TOKEN："))
        self.label_2.setText(_translate("Form", "DC 频道："))
        self.label_3.setText(_translate("Form", "API KEY："))
        self.label_4.setText(_translate("Form", "延时（秒）："))
        self.label_5.setText(_translate("Form", "-"))
        self.label_6.setText(_translate("Form", "回复语言："))
        self.pushButton_2.setText(_translate("Form", "开始"))
        self.pushButton.setText(_translate("Form", "停止"))
    
    def load_config(self):
        """加载保存的配置"""
        if os.path.exists(self.config_file):
            try:
                with open(self.config_file, 'r') as f:
                    config = json.load(f)
                    
                    # 填充保存的值到对应的输入框
                    self.lineEdit.setText(config.get('dc_token', ''))
                    self.lineEdit_2.setText(config.get('dc_channel', ''))
                    self.lineEdit_3.setText(config.get('api_key', ''))
                    self.lineEdit_4.setText(config.get('delay_min', '300'))
                    self.lineEdit_5.setText(config.get('delay_max', '350'))
                    
                    # 设置语言选择
                    language_index = config.get('language_index', 0)  # 默认中文
                    if 0 <= language_index < self.comboBox_language.count():
                        self.comboBox_language.setCurrentIndex(language_index)
            except Exception as e:
                print(f"读取配置文件出错: {e}")
                self.log_message(f"读取配置文件出错: {e}")
    
    def save_config(self):
        """保存当前配置"""
        config = {
            'dc_token': self.lineEdit.text(),
            'dc_channel': self.lineEdit_2.text(),
            'api_key': self.lineEdit_3.text(),
            'delay_min': self.lineEdit_4.text(),
            'delay_max': self.lineEdit_5.text(),
            'language_index': self.comboBox_language.currentIndex()
        }
        
        try:
            with open(self.config_file, 'w') as f:
                json.dump(config, f)
        except Exception as e:
            print(f"保存配置文件出错: {e}")
            self.log_message(f"保存配置文件出错: {e}")
    
    def update_log(self, message):
        """更新日志（线程安全）"""
        timestamp = datetime.now().strftime('[%H:%M:%S]')
        self.plainTextEdit.appendPlainText(f"{timestamp} {message}")
    
    def log_message(self, message):
        """在文本框中记录消息（通过信号发送）"""
        self.signals.log_signal.emit(message)
    
    def handle_close_event(self, event):
        """处理窗口关闭事件"""
        if self.running:
            self.stop_bot()
            # 等待线程完全停止
            time.sleep(0.5)
        event.accept()
    
    def get_messages(self):
        """获取Discord频道消息"""
        try:
            discord_token = self.lineEdit.text()
            channel_id = self.lineEdit_2.text()
            
            if not discord_token or not channel_id:
                self.log_message("Discord Token 或频道 ID 为空")
                return []
            
            url = f"https://discord.com/api/v10/channels/{channel_id}/messages?limit=20"
            headers = {"Authorization": discord_token}
            
            # 添加超时设置
            response = requests.get(url, headers=headers, timeout=30)
            
            if response.status_code == 200:
                data = response.json()
                # 过滤消息内容，排除包含特定字符的消息
                messages = [msg["content"] for msg in data if not any(char in msg["content"] for char in "<>@http?0x")]
                return messages
            else:
                error_msg = f"获取消息失败: {response.status_code}"
                if response.status_code == 401:
                    error_msg += " - Token 可能无效"
                elif response.status_code == 404:
                    error_msg += " - 频道 ID 可能无效"
                self.log_message(error_msg)
                return []
        except requests.exceptions.Timeout:
            self.log_message("获取消息超时，请检查网络连接")
            return []
        except requests.exceptions.ConnectionError:
            self.log_message("网络连接错误，请检查网络连接")
            return []
        except Exception as e:
            self.log_message(f"请求错误: {str(e)}")
            # 记录详细错误信息
            traceback.print_exc()
            return []
    
    def generate_response(self, messages):
        """使用AI生成回复"""
        try:
            api_key = self.lineEdit_3.text()
            
            if not api_key:
                self.log_message("API Key 为空")
                return ''
            
            language = self.comboBox_language.currentText()
            
            # 根据选择的语言构建不同的提示词

            ai_prompt = """你现在是一个Discord群聊中的普通用户，你需要用最自然的方式回复消息。请注意：
                1. 回复要像真实用户一样简短随意，不要太正式
                2. 不要使用任何标点符号
                3. 每次回复限制在10个字以内
                4. 可以偶尔使用网络用语 但要自然
                5. 不要过分热情 保持随意的语气
                6. 不要每句话都很认真 可以偶尔调侃
                7. 避免使用机器人式的固定句式
                8. 根据上下文自然接话 不要刻意引导话题
                9. 不要使用任何敏感词或不当用语
                10. 模仿当前聊天氛围 融入群众
                11. 不要使用"哈哈""嘻嘻""嘿嘿"等语气词
                记住你只是一个普通用户 用最简单自然的方式回应即可
                当前聊天记录："""

            # 将消息列表转换为字符串
            messages_text = "\n".join(messages)
            
            url = 'https://geekai.dev/api/v1/chat/completions'
            headers = {
                'Authorization': f'Bearer {api_key}',
                'Content-Type': 'application/json'
            }
            data = {
                'model': 'gpt-4o',
                'messages': [{'role': 'user', 'content': ai_prompt + messages_text + '并且将生成的结果翻译成:' + language + "。只回复翻译后的结果"}],
                'stream': False
            }
            
            # 添加超时设置
            response = requests.post(url, headers=headers, json=data, timeout=60)
            
            if response.status_code == 200:
                result = response.json()
                reply = result.get('choices', [{}])[0].get('message', {}).get('content', '')
                return reply
            else:
                error_msg = f"AI 生成失败: {response.status_code}"
                if response.status_code == 401:
                    error_msg += " - API Key 可能无效"
                self.log_message(error_msg)
                return ''
        except requests.exceptions.Timeout:
            self.log_message("AI 请求超时，请检查网络连接")
            return ''
        except requests.exceptions.ConnectionError:
            self.log_message("网络连接错误，请检查网络连接")
            return ''
        except Exception as e:
            self.log_message(f"AI 请求错误: {str(e)}")
            # 记录详细错误信息
            traceback.print_exc()
            return ''
    
    def send_message(self, message):
        """发送消息到Discord频道"""
        try:
            discord_token = self.lineEdit.text()
            channel_id = self.lineEdit_2.text()
            
            if not discord_token or not channel_id:
                self.log_message("Discord Token 或频道 ID 为空")
                return False
            
            url = f"https://discord.com/api/v10/channels/{channel_id}/messages"
            headers = {
                'Authorization': discord_token,
                'Content-Type': 'application/json'
            }
            data = {
                'content': message,
                'tts': False
            }
            
            # 添加超时设置
            response = requests.post(url, headers=headers, json=data, timeout=30)
            
            if response.status_code == 200:
                self.log_message(f"发送成功: {message}")
                return True
            else:
                error_msg = f"发送失败: {response.status_code}"
                if response.status_code == 401:
                    error_msg += " - Token 可能无效"
                elif response.status_code == 404:
                    error_msg += " - 频道 ID 可能无效"
                self.log_message(error_msg)
                return False
        except requests.exceptions.Timeout:
            self.log_message("发送消息超时，请检查网络连接")
            return False
        except requests.exceptions.ConnectionError:
            self.log_message("网络连接错误，请检查网络连接")
            return False
        except Exception as e:
            self.log_message(f"发送错误: {str(e)}")
            # 记录详细错误信息
            traceback.print_exc()
            return False
    
    def get_random_delay(self):
        """获取随机延迟时间（秒）"""
        try:
            min_delay = int(self.lineEdit_4.text())
            max_delay = int(self.lineEdit_5.text())
            return random.randint(min_delay, max_delay)
        except ValueError:
            self.log_message("延时设置错误，使用默认值")
            return random.randint(300, 350)
    
    def bot_loop(self):
        """机器人主循环"""
        self.log_message("机器人已启动")
        
        while self.running:
            try:
                # 获取消息
                messages = self.get_messages()
                
                if not self.running:  # 检查是否在获取消息期间被停止
                    break
                
                if messages:
                    # 生成回复
                    reply = self.generate_response(messages)
                    
                    if not self.running:  # 检查是否在生成回复期间被停止
                        break
                    
                    self.log_message(f"AI生成结果: {reply}")
                    
                    if reply and self.running:
                        # 发送消息
                        self.send_message(reply)
                        
                        if not self.running:  # 检查是否在发送消息期间被停止
                            break
                        
                        # 随机延迟
                        delay = self.get_random_delay()
                        self.log_message(f"等待 {delay} 秒...")
                        
                        # 分段睡眠，每5秒检查一次是否应该停止
                        for _ in range(delay // 5):
                            if not self.running:
                                break
                            time.sleep(5)
                        
                        # 处理剩余的时间
                        if self.running and delay % 5 > 0:
                            time.sleep(delay % 5)
                else:
                    # 没有消息时也需要延迟
                    delay = self.get_random_delay()
                    self.log_message(f"没有新消息，等待 {delay} 秒...")
                    
                    # 分段睡眠，每5秒检查一次是否应该停止
                    for _ in range(delay // 5):
                        if not self.running:
                            break
                        time.sleep(5)
                    
                    # 处理剩余的时间
                    if self.running and delay % 5 > 0:
                        time.sleep(delay % 5)
            except Exception as e:
                if self.running:  # 只有在仍然运行时才记录错误
                    self.log_message(f"执行错误: {str(e)}")
                    # 记录详细错误信息
                    traceback.print_exc()
                    # 发生错误时等待一段时间再继续
                    time.sleep(5)
        
        self.log_message("机器人已停止")
    
    def start_bot(self):
        """启动机器人"""
        if self.running:
            self.log_message("机器人已经在运行中")
            return
        
        # 检查必要的配置
        if not self.lineEdit.text() or not self.lineEdit_2.text() or not self.lineEdit_3.text():
            QMessageBox.warning(self, "配置错误", "请填写Discord Token、频道ID和API Key")
            return
        
        try:
            # 检查延时设置是否为有效数字
            min_delay = int(self.lineEdit_4.text())
            max_delay = int(self.lineEdit_5.text())
            
            if min_delay <= 0 or max_delay <= 0:
                QMessageBox.warning(self, "配置错误", "延时设置必须为正数")
                return
            
            if min_delay > max_delay:
                QMessageBox.warning(self, "配置错误", "最小延时不能大于最大延时")
                return
        except ValueError:
            QMessageBox.warning(self, "配置错误", "延时设置必须为数字")
            return
        
        self.running = True
        self.bot_thread = threading.Thread(target=self.bot_loop)
        self.bot_thread.daemon = True  # 设置为守护线程，这样主程序退出时线程也会退出
        self.bot_thread.start()
        
        # 禁用开始按钮，启用停止按钮
        self.pushButton_2.setEnabled(False)
        self.pushButton.setEnabled(True)
    
    def stop_bot(self):
        """停止机器人"""
        if not self.running:
            self.log_message("机器人未运行")
            return
        
        self.log_message("正在停止机器人...")
        self.running = False
        
        # 不再调用 join，避免界面卡死
        # 线程会在下一次循环检查时自行退出
        
        # 启用开始按钮，禁用停止按钮
        self.pushButton_2.setEnabled(True)
        self.pushButton.setEnabled(False)


if __name__ == '__main__':
    app = QtWidgets.QApplication(sys.argv)
    
    # 设置全局异常处理
    def exception_hook(exctype, value, traceback_obj):
        """全局异常处理函数"""
        traceback.print_exception(exctype, value, traceback_obj)
        error_msg = f"{exctype.__name__}: {value}"
        QMessageBox.critical(None, "错误", f"程序发生错误:\n{error_msg}\n\n请查看控制台获取详细信息。")
        # 不退出程序，让用户有机会看到错误信息
    
    sys.excepthook = exception_hook
    
    Form = QtWidgets.QWidget()
    ui = Ui_Form()
    ui.show()
    sys.exit(app.exec())